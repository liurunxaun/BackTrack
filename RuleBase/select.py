# 不采用倒推的形式，转而从由条件构建的树经过去重后，不经过目的的硬性筛选，而是直接交给大模型，让他结合问题，选择留下哪些本体路径。
# 实际上倒推是“规则”的进阶版，“规则”是让大模型直接选路径，倒推是先让大模型从问题中提取出意图来，再硬性筛选
# 可以说是两种筛选路径的方式
# 但是把问题和所有待选路径一并直接交给大模型，或许会参考信息更多，效果更好

from utils import llm_api as llm
import re


def select_rules(paths, question):
    """
    输入：全部条件的全部本体路径，用户的问题
    处理过程：一并交给大模型，筛选出回答问题有用的本体路径
    输出：筛选出来的路径（或者说规则）
    """

    rules = []

    print(f"paths_waited:{paths}")

    query = f"""
    我会给你用户的问题，和一些可能用得到的推理路径。我需要你结合用户问题，筛选推理路径，并输出
    用户输入的问题:{question}\n
    待筛选推理路径:{paths}\n
    下面是一些解释信息：
    我用大模型从问题中提取出来了已知条件。并从已知条件出发，在我的领域知识图谱本体中深度优先搜索提取出了以这个条件的标签为起点的全部本体路径，作为推理路径。
    我希望你从这些本体路径中筛选出回答问题可能会用到的路径。后面我会以这些推理路径为指导，到知识图谱中检索实体。
    """

    response = llm.spark_4_0(query)

    pattern = r"\['(.*?)'\]"  # 匹配类似 ['领域', '标题', '方法'] 的结构
    matches = re.findall(pattern, response)

    # 将匹配结果转换为二维列表
    rules = [match.split("', '") for match in matches]

    return rules
